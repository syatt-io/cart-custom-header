import type { FC } from 'react'
import React, { useMemo, useReducer, useEffect, useState } from 'react'

import { shouldUpdateOrderForm } from '../utils/heuristics'
import { DEFAULT_ORDER_FORM_ID, UNSYNC_ORDER_FORM_VALUE } from '../constants'
import { useQueueStatus } from '../OrderQueue'
import type {
  OrderForm,
  OrderFormUpdate,
  Context,
  PossibleOrderForms,
} from '../typings'
import type { createUseMessages } from './createUseMessages'
import { OrderFormContext } from './OrderForm'
import type { LogFn, UseLogger } from './logger'

const saveLocalOrderForm = (orderForm: OrderForm, log?: LogFn) => {
  try {
    if (navigator.cookieEnabled) {
      localStorage.setItem('orderform', JSON.stringify(orderForm))
    }
  } catch (error) {
    // ignored, can be caused due to quota exceeded
    // only offline navigation will be affected
    log?.({
      type: 'Error',
      level: 'Critical',
      event: error,
      workflowType: 'OrderManager',
      workflowInstance: 'save-local-orderform',
    })
  }
}

function getLocalOrderForm<O>(): O | null {
  if (typeof document === 'undefined' || !navigator.cookieEnabled) {
    return null
  }

  return JSON.parse(localStorage.getItem('orderform') ?? 'null')
}

function reducer<O extends OrderForm>(
  prevOrderForm: PossibleOrderForms<O>,
  updateOrderForm: OrderFormUpdate<O>
): PossibleOrderForms<O> {
  if (typeof updateOrderForm === 'function') {
    return {
      ...prevOrderForm,
      ...updateOrderForm({
        ...prevOrderForm,
        value:
          prevOrderForm.value === UNSYNC_ORDER_FORM_VALUE
            ? 0
            : prevOrderForm.value,
      }),
    }
  }

  return {
    ...prevOrderForm,
    ...updateOrderForm,
  }
}

interface GetOrderFormHookArgs<O extends OrderForm> {
  orderForm: O
  setOrderForm: (update: OrderFormUpdate<O>) => void
}

export interface CreateOrderFormProviderParams<O extends OrderForm> {
  useOrderFormMessages: ReturnType<typeof createUseMessages>
  useGetOrderForm: (
    args: GetOrderFormHookArgs<O>
  ) => {
    data?: { orderForm: O }
    loading: boolean
    error?: any
  }
  defaultOrderForm: O
  useLogger?: UseLogger
}

export function createOrderFormProvider<O extends OrderForm>({
  useOrderFormMessages,
  useGetOrderForm,
  useLogger,
  defaultOrderForm,
}: CreateOrderFormProviderParams<O>) {
  const OrderFormProvider: FC = ({ children }) => {
    const { log } = useLogger?.() ?? {}
    const shouldUseLocalOrderForm =
      typeof document !== 'undefined' && !navigator.onLine

    const [orderForm, setOrderForm] = useReducer(
      reducer,
      (shouldUseLocalOrderForm
        ? getLocalOrderForm<PossibleOrderForms<O>>()
        : defaultOrderForm) ?? defaultOrderForm
    )

    const { loading, data, error } = useGetOrderForm({
      orderForm: orderForm as O,
      setOrderForm: setOrderForm as React.Dispatch<OrderFormUpdate<O>>,
    })

    // use a different variable to store the loading state because if some
    // component uses the `loading` from the Apollo query they won't be perfectly
    // synchronized with our `orderForm` state and could cause some anomalies.
    const [orderFormLoading, setOrderFormLoading] = useState(
      !shouldUseLocalOrderForm
    )

    const queueStatusRef = useQueueStatus()

    useEffect(() => {
      if (loading || error || !data) {
        return
      }

      const localOrderForm = getLocalOrderForm<PossibleOrderForms<O>>()

      if (localOrderForm != null) {
        if (
          !shouldUpdateOrderForm(localOrderForm, data.orderForm) ||
          // if the queue is fulfilled, we will use the remote order form
          // regardless of the local status.
          //
          // if the queue is pending the remote order form isn't important because
          // it is expected that when the last task in the queue is finalized, the
          // component will call `setOrderForm` with the most up-to-date value.
          queueStatusRef.current !== 'Fulfilled'
        ) {
          setOrderFormLoading(false)
          setOrderForm((prevOrderForm) => {
            if (prevOrderForm.id !== defaultOrderForm.id) {
              return prevOrderForm
            }

            return localOrderForm
          })

          return
        }
      }

      setOrderForm(data.orderForm)
      setOrderFormLoading(false)
    }, [data, error, loading, queueStatusRef])

    useEffect(() => {
      saveLocalOrderForm(orderForm, log)
    }, [log, orderForm])

    useOrderFormMessages(orderForm, setOrderForm)

    const value = useMemo<Context<OrderForm>>(() => {
      if (orderForm.id !== DEFAULT_ORDER_FORM_ID) {
        return {
          error,
          orderForm: {
            ...orderForm,
            value:
              orderForm.value === UNSYNC_ORDER_FORM_VALUE ? 0 : orderForm.value,
            messages: {
              ...orderForm.messages,
              generalMessages: [],
            },
          },
          initialFetchComplete: true,
          setOrderForm,
          loading: orderFormLoading,
        }
      }

      return {
        error,
        orderForm: {
          ...orderForm,
          value:
            orderForm.value === UNSYNC_ORDER_FORM_VALUE ? 0 : orderForm.value,
          messages: {
            ...orderForm.messages,
            generalMessages: [],
          },
        },
        initialFetchComplete: false,
        setOrderForm,
        loading: orderFormLoading,
      }
    }, [error, orderForm, orderFormLoading])

    return (
      <OrderFormContext.Provider value={value}>
        {children}
      </OrderFormContext.Provider>
    )
  }

  return { OrderFormProvider }
}
