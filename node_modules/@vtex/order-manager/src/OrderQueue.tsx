import type { ReactNode, VFC, RefObject } from 'react'
import React, {
  useLayoutEffect,
  createContext,
  useContext,
  useMemo,
  useRef,
  useState,
} from 'react'

import type { OrderForm, QueueStatus } from './typings'
import { TaskQueue } from './modules/TaskQueue'
import type { CancellablePromiseLike } from './modules/SequentialTaskQueue'

type ListenFunction = (event: QueueStatus, callback: () => void) => () => void

export interface Context<O extends OrderForm> {
  enqueue: (task: () => Promise<O>, id?: string) => CancellablePromiseLike<O>
  listen: ListenFunction
  isWaiting: (id: string) => boolean
  status: RefObject<QueueStatus>
}

export interface OrderQueueProviderProps {
  children: ReactNode
}

const OrderQueueContext = createContext<Context<OrderForm> | undefined>(
  undefined
)

export const useQueueStatus = () => {
  const { status } = useOrderQueue()

  return status
}

export const OrderQueueProvider: VFC<OrderQueueProviderProps> = ({
  children,
}) => {
  const [queue] = useState(() => new TaskQueue())
  const status = useRef<QueueStatus>('Fulfilled')

  useLayoutEffect(() => {
    const unlisten = queue.listen('Pending', () => (status.current = 'Pending'))

    return unlisten
  }, [queue])

  useLayoutEffect(() => {
    const unlisten = queue.listen(
      'Fulfilled',
      () => (status.current = 'Fulfilled')
    )

    return unlisten
  }, [queue])

  const value = useMemo(
    () => ({
      enqueue: queue.enqueue.bind(queue),
      listen: queue.listen.bind(queue),
      isWaiting: queue.isWaiting.bind(queue),
      status,
    }),
    [queue, status]
  )

  return (
    <OrderQueueContext.Provider value={value}>
      {children}
    </OrderQueueContext.Provider>
  )
}

export function useOrderQueue<O extends OrderForm>() {
  const context = useContext(OrderQueueContext)

  if (context === undefined) {
    throw new Error('useOrderQueue must be used within a OrderQueueProvider')
  }

  return (context as unknown) as Context<O>
}
