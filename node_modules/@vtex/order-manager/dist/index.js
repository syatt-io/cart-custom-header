/*!
 * @vtex/order-manager v0.5.4-beta.0
 * (c) VTEX
 * Released under the MIT License.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

// Adapted from https://github.com/BalassaMarton/sequential-task-queue/blob/master/src/sequential-task-queue.ts
/**
 * Standard cancellation reasons. {@link SequentialTaskQueue} sets {@link CancellationToken.reason}
 * to one of these values when cancelling a task for a reason other than the user code calling
 * {@link CancellationToken.cancel}.
 */
const cancellationTokenReasons = {
    /** Used when the task was cancelled in response to a call to {@link SequentialTaskQueue.cancel} */
    cancel: Object.create(null),
    /** Used when the task was cancelled after its timeout has passed */
    timeout: Object.create(null),
};
/**
 * Standard event names used by {@link SequentialTaskQueue}
 */
const sequentialTaskQueueEvents = {
    drained: 'drained',
    error: 'error',
    timeout: 'timeout',
};
function isPromise(obj) {
    return obj && typeof obj.then === 'function';
}
function noop$1() { }
/**
 * FIFO task queue to run tasks in predictable order, without concurrency.
 */
class SequentialTaskQueue {
    /**
     * Creates a new instance of {@link SequentialTaskQueue}
     * @param options - Configuration options for the task queue.
     */
    constructor(options) {
        var _a, _b;
        this.queue = [];
        this._isClosed = false;
        this.waiters = [];
        if (!options)
            options = {};
        this.defaultTimeout = options.timeout;
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : 'SequentialTaskQueue';
        this.scheduler = (_b = options.scheduler) !== null && _b !== void 0 ? _b : SequentialTaskQueue.defaultScheduler;
    }
    /** Indicates if the queue has been closed. Calling {@link SequentialTaskQueue.push} on a closed queue will result in an exception. */
    get isClosed() {
        return this._isClosed;
    }
    /**
     * Adds a new task to the queue.
     * @param {Function} task - The function to call when the task is run
     * @param {TaskOptions} options - An object containing arguments and options for the task.
     * @returns {CancellablePromiseLike<any>} A promise that can be used to await or cancel the task.
     */
    push(task, options) {
        if (this._isClosed) {
            throw new Error(`${this.name} has been previously closed`);
        }
        const taskEntry = {
            callback: task,
            args: (options === null || options === void 0 ? void 0 : options.args)
                ? Array.isArray(options.args)
                    ? options.args.slice()
                    : [options.args]
                : [],
            timeout: (options === null || options === void 0 ? void 0 : options.timeout) !== undefined ? options.timeout : this.defaultTimeout,
            cancellationToken: {
                cancel: (reason) => this.cancelTask(taskEntry, reason),
            },
            resolve: undefined,
            reject: undefined,
        };
        taskEntry.args.push(taskEntry.cancellationToken);
        this.queue.push(taskEntry);
        this.scheduler.schedule(() => this.next());
        const result = new Promise((resolve, reject) => {
            taskEntry.resolve = resolve;
            taskEntry.reject = reject;
        });
        result.cancel = (reason) => taskEntry.cancellationToken.cancel(reason);
        return result;
    }
    /**
     * Cancels the currently running task (if any), and clears the queue.
     * @returns {Promise} A Promise that is fulfilled when the queue is empty and the current task has been cancelled.
     */
    cancel() {
        if (this.currentTask) {
            this.cancelTask(this.currentTask, cancellationTokenReasons.cancel);
        }
        const queue = this.queue.splice(0);
        // Cancel all and emit a drained event if there were tasks waiting in the queue
        if (queue.length) {
            queue.forEach((task) => this.cancelTask(task, cancellationTokenReasons.cancel));
            this.emit(sequentialTaskQueueEvents.drained);
        }
        return this.wait();
    }
    indexOf(task) {
        var _a;
        if (((_a = this.currentTask) === null || _a === void 0 ? void 0 : _a.callback) === task) {
            return 0;
        }
        const queueIndex = this.queue
            // Skip cancelled tasks
            .filter((taskEntry) => { var _a; return !((_a = taskEntry.cancellationToken) === null || _a === void 0 ? void 0 : _a.cancelled); })
            .findIndex((taskEntry) => taskEntry.callback === task);
        if (queueIndex < 0) {
            // Task not found, return -1
            return queueIndex;
        }
        // The `currentTask` is also part of the queue, although
        // it isn't in the `queue` array, so we should account for
        // its existence and shift the index by 1 if it is set.
        return queueIndex + (this.currentTask !== undefined ? 1 : 0);
    }
    /**
     * Closes the queue, preventing new tasks to be added.
     * Any calls to {@link SequentialTaskQueue.push} after closing the queue will result in an exception.
     * @param {boolean} cancel - Indicates that the queue should also be cancelled.
     * @returns {Promise} A Promise that is fulfilled when the queue has finished executing remaining tasks.
     */
    close(cancel) {
        if (!this._isClosed) {
            this._isClosed = true;
            if (cancel)
                return this.cancel();
        }
        return this.wait();
    }
    /**
     * Returns a promise that is fulfilled when the queue is empty.
     * @returns {Promise}
     */
    async wait() {
        if (!this.currentTask && this.queue.length === 0)
            return Promise.resolve();
        return new Promise((resolve) => {
            this.waiters.push(resolve);
        });
    }
    /**
     * Adds an event handler for a named event.
     * @param {string} evt - Event name. See the readme for a list of valid events.
     * @param {Function} handler - Event handler. When invoking the handler, the queue will set itself as the `this` argument of the call.
     */
    on(evt, handler) {
        var _a;
        this.events = (_a = this.events) !== null && _a !== void 0 ? _a : {};
        (this.events[evt] || (this.events[evt] = [])).push(handler);
    }
    /**
     * Adds a single-shot event handler for a named event.
     * @param {string} evt - Event name. See the readme for a list of valid events.
     * @param {Function} handler - Event handler. When invoking the handler, the queue will set itself as the `this` argument of the call.
     */
    once(evt, handler) {
        const cb = (...args) => {
            this.removeListener(evt, cb);
            handler.apply(this, args);
        };
        this.on(evt, cb);
    }
    /**
     * Removes an event handler.
     * @param {string} evt - Event name
     * @param {Function} handler - Event handler to be removed
     */
    removeListener(evt, handler) {
        if (this.events) {
            const list = this.events[evt];
            if (list) {
                let i = 0;
                while (i < list.length) {
                    if (list[i] === handler)
                        list.splice(i, 1);
                    else
                        i++;
                }
            }
        }
    }
    /** @see {@link SequentialTaskQueue.removeListener} */
    off(evt, handler) {
        return this.removeListener(evt, handler);
    }
    emit(evt, ...args) {
        var _a;
        if ((_a = this.events) === null || _a === void 0 ? void 0 : _a[evt]) {
            try {
                this.events[evt].forEach((fn) => fn.apply(this, args));
            }
            catch (e) {
                console.error(`${this.name}: Exception in '${evt}' event handler`, e);
            }
        }
    }
    next() {
        // Try running the next task, if not currently running one
        if (!this.currentTask) {
            let task = this.queue.shift();
            // skip cancelled tasks
            while (task === null || task === void 0 ? void 0 : task.cancellationToken.cancelled)
                task = this.queue.shift();
            if (task) {
                try {
                    this.currentTask = task;
                    if (task.timeout) {
                        task.timeoutHandle = setTimeout(() => {
                            this.emit(sequentialTaskQueueEvents.timeout);
                            this.cancelTask(task, cancellationTokenReasons.timeout);
                        }, task.timeout);
                    }
                    const res = task.callback.apply(undefined, task.args);
                    if (res && isPromise(res)) {
                        res.then((result) => {
                            task.result = result;
                            this.doneTask(task);
                        }, (err) => {
                            this.doneTask(task, err);
                        });
                    }
                    else {
                        task.result = res;
                        this.doneTask(task);
                    }
                }
                catch (e) {
                    this.doneTask(task, e);
                }
            }
            else {
                // queue is empty, call waiters
                this.callWaiters();
            }
        }
    }
    cancelTask(task, reason) {
        task.cancellationToken.cancelled = true;
        task.cancellationToken.reason = reason;
        this.doneTask(task);
    }
    doneTask(task, error) {
        if (task.timeoutHandle)
            clearTimeout(task.timeoutHandle);
        task.cancellationToken.cancel = noop$1;
        if (error) {
            this.emit(sequentialTaskQueueEvents.error, error);
            task.reject.call(undefined, error);
        }
        else if (task.cancellationToken.cancelled) {
            task.reject.call(undefined, task.cancellationToken.reason);
        }
        else {
            task.resolve.call(undefined, task.result);
        }
        if (this.currentTask === task) {
            this.currentTask = undefined;
            if (!this.queue.length) {
                this.emit(sequentialTaskQueueEvents.drained);
                this.callWaiters();
            }
            else {
                this.scheduler.schedule(() => this.next());
            }
        }
    }
    callWaiters() {
        const waiters = this.waiters.splice(0);
        waiters.forEach((waiter) => waiter());
    }
}
SequentialTaskQueue.defaultScheduler = {
    schedule: (callback) => setTimeout(() => callback(), 0),
};
SequentialTaskQueue.defaultScheduler = {
    schedule: typeof setImmediate === 'function'
        ? (callback) => setImmediate(() => callback())
        : (callback) => setTimeout(() => callback(), 0),
};

const TASK_CANCELLED_CODE = 'TASK_CANCELLED';
// keep default value as -1 to indicate this order form
// is the initial value (not yet synchonized with server).
const UNSYNC_ORDER_FORM_VALUE = -1;
const DEFAULT_ORDER_FORM_ID = 'default-order-form';
const DEFAULT_ORDER_FORM = {
    id: DEFAULT_ORDER_FORM_ID,
    items: [],
    value: UNSYNC_ORDER_FORM_VALUE,
    totalizers: [],
    marketingData: {},
    canEditData: false,
    loggedIn: false,
    paymentData: {
        isValid: false,
        installmentOptions: [],
        paymentSystems: [],
        payments: [],
        availableAccounts: [],
    },
    messages: {
        couponMessages: [],
        generalMessages: [],
    },
    shipping: {
        isValid: false,
        deliveryOptions: [],
        pickupOptions: [],
    },
};

class TaskQueue {
    constructor() {
        this.queue = new SequentialTaskQueue();
        this.taskIdMap = {};
        this.listeners = {};
        this.isEmpty = true;
        this.queue.on('drained', () => {
            this.isEmpty = true;
            this.emit('Fulfilled');
        });
    }
    isWaiting(id) {
        return !!this.taskIdMap[id];
    }
    enqueue(task, id) {
        if (this.isEmpty) {
            this.isEmpty = false;
            this.emit('Pending');
        }
        if (id && this.taskIdMap[id]) {
            this.taskIdMap[id].promise.cancel();
        }
        const wrappedTask = () => {
            if (id && this.taskIdMap[id]) {
                delete this.taskIdMap[id];
            }
            return new Promise((resolve, reject) => {
                const handleOnline = async () => {
                    try {
                        const result = await task();
                        resolve(result);
                    }
                    catch (err) {
                        // we might have gone offline when this request was in-flight
                        // so we need to wait to be online again and replay this request
                        if (!navigator.onLine) {
                            return;
                        }
                        reject(err);
                    }
                    window.removeEventListener('online', handleOnline);
                };
                window.addEventListener('online', handleOnline);
                if (navigator.onLine) {
                    handleOnline();
                }
            });
        };
        const promise = this.queue.push(wrappedTask);
        const cancelPromise = promise.cancel;
        promise.cancel = () => cancelPromise({
            code: TASK_CANCELLED_CODE,
            index: this.queue.indexOf(wrappedTask),
        });
        if (id) {
            this.taskIdMap[id] = {
                task,
                promise,
            };
        }
        return promise;
    }
    listen(event, cb) {
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        this.listeners[event].push(cb);
        const unlisten = () => {
            const index = this.listeners[event].indexOf(cb);
            if (index !== -1) {
                this.listeners[event].splice(index, 1);
            }
        };
        return unlisten;
    }
    emit(event) {
        if (this.listeners[event]) {
            this.listeners[event].forEach((cb) => cb());
        }
    }
}

const OrderQueueContext = React.createContext(undefined);
const useQueueStatus = () => {
    const { status } = useOrderQueue();
    return status;
};
const OrderQueueProvider = ({ children, }) => {
    const [queue] = React.useState(() => new TaskQueue());
    const status = React.useRef('Fulfilled');
    React.useLayoutEffect(() => {
        const unlisten = queue.listen('Pending', () => (status.current = 'Pending'));
        return unlisten;
    }, [queue]);
    React.useLayoutEffect(() => {
        const unlisten = queue.listen('Fulfilled', () => (status.current = 'Fulfilled'));
        return unlisten;
    }, [queue]);
    const value = React.useMemo(() => ({
        enqueue: queue.enqueue.bind(queue),
        listen: queue.listen.bind(queue),
        isWaiting: queue.isWaiting.bind(queue),
        status,
    }), [queue, status]);
    return (React__default['default'].createElement(OrderQueueContext.Provider, { value: value }, children));
};
function useOrderQueue() {
    const context = React.useContext(OrderQueueContext);
    if (context === undefined) {
        throw new Error('useOrderQueue must be used within a OrderQueueProvider');
    }
    return context;
}

const createUseMessages = ({ useClearOrderFormMessages, useToast, }) => {
    const useOrderFormMessages = (orderForm, setOrderForm) => {
        const [messages, setMessages] = React.useState([]);
        const { showToast, toastState } = useToast();
        const { enqueue } = useOrderQueue();
        const queueStatusRef = useQueueStatus();
        const clearOrderFormMessages = useClearOrderFormMessages();
        React.useEffect(() => {
            if (toastState.isToastVisible || !messages.length) {
                return;
            }
            showToast(messages[0].text);
            setMessages((queue) => queue.slice(1));
        }, [showToast, toastState.isToastVisible, messages]);
        React.useEffect(() => {
            var _a, _b;
            if (!((_b = (_a = orderForm.messages) === null || _a === void 0 ? void 0 : _a.generalMessages) === null || _b === void 0 ? void 0 : _b.length)) {
                return;
            }
            setMessages((prevMessages) => { var _a, _b; return prevMessages.concat((_b = (_a = orderForm.messages) === null || _a === void 0 ? void 0 : _a.generalMessages) !== null && _b !== void 0 ? _b : []); });
            setOrderForm((prevOrderForm) => {
                return {
                    ...prevOrderForm,
                    messages: {
                        ...prevOrderForm.messages,
                        generalMessages: [],
                    },
                };
            });
            const enqueuePromise = enqueue(async () => {
                const { data } = await clearOrderFormMessages({
                    orderFormId: orderForm.id,
                });
                return data.clearOrderFormMessages;
            });
            enqueuePromise.then((updatedOrderForm) => {
                if (queueStatusRef.current === 'Fulfilled') {
                    setOrderForm(updatedOrderForm);
                }
            }, (err) => {
                if (err.code === TASK_CANCELLED_CODE) {
                    return;
                }
                throw err;
            });
        }, [
            clearOrderFormMessages,
            enqueue,
            orderForm.id,
            orderForm.messages,
            queueStatusRef,
            setOrderForm,
        ]);
    };
    return useOrderFormMessages;
};

var _a, _b, _c, _d, _e;
const canUseDOM = !!(typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement);
const orderFormOptimizationEnabled = (_e = (canUseDOM &&
    ((_d = (_c = (_b = (_a = window) === null || _a === void 0 ? void 0 : _a.__RUNTIME__) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c['vtex.store']) === null || _d === void 0 ? void 0 : _d.enableOrderFormOptimization))) !== null && _e !== void 0 ? _e : false;
/**
 * Heuristic function to determine whether or not the local
 * order form (stored in localStorage) should be replaced by
 * the remote order form.
 */
const shouldUpdateOrderForm = (localOrderForm, remoteOrderForm) => {
    return (localOrderForm.value === UNSYNC_ORDER_FORM_VALUE ||
        (orderFormOptimizationEnabled &&
            localOrderForm.id !== remoteOrderForm.id &&
            localOrderForm.id !== DEFAULT_ORDER_FORM_ID));
};

const noop = () => { };
const OrderFormContext = React.createContext({
    orderForm: DEFAULT_ORDER_FORM,
    setOrderForm: noop,
    error: undefined,
    loading: false,
});
function useOrderForm() {
    const context = React.useContext(OrderFormContext);
    if (context === undefined) {
        throw new Error('useOrderForm must be used within a OrderFormProvider');
    }
    return context;
}

const saveLocalOrderForm = (orderForm, log) => {
    try {
        if (navigator.cookieEnabled) {
            localStorage.setItem('orderform', JSON.stringify(orderForm));
        }
    }
    catch (error) {
        // ignored, can be caused due to quota exceeded
        // only offline navigation will be affected
        log === null || log === void 0 ? void 0 : log({
            type: 'Error',
            level: 'Critical',
            event: error,
            workflowType: 'OrderManager',
            workflowInstance: 'save-local-orderform',
        });
    }
};
function getLocalOrderForm() {
    var _a;
    if (typeof document === 'undefined' || !navigator.cookieEnabled) {
        return null;
    }
    return JSON.parse((_a = localStorage.getItem('orderform')) !== null && _a !== void 0 ? _a : 'null');
}
function reducer(prevOrderForm, updateOrderForm) {
    if (typeof updateOrderForm === 'function') {
        return {
            ...prevOrderForm,
            ...updateOrderForm({
                ...prevOrderForm,
                value: prevOrderForm.value === UNSYNC_ORDER_FORM_VALUE
                    ? 0
                    : prevOrderForm.value,
            }),
        };
    }
    return {
        ...prevOrderForm,
        ...updateOrderForm,
    };
}
function createOrderFormProvider$1({ useOrderFormMessages, useGetOrderForm, useLogger, defaultOrderForm, }) {
    const OrderFormProvider = ({ children }) => {
        var _a, _b;
        const { log } = (_a = useLogger === null || useLogger === void 0 ? void 0 : useLogger()) !== null && _a !== void 0 ? _a : {};
        const shouldUseLocalOrderForm = typeof document !== 'undefined' && !navigator.onLine;
        const [orderForm, setOrderForm] = React.useReducer(reducer, (_b = (shouldUseLocalOrderForm
            ? getLocalOrderForm()
            : defaultOrderForm)) !== null && _b !== void 0 ? _b : defaultOrderForm);
        const { loading, data, error } = useGetOrderForm({
            orderForm: orderForm,
            setOrderForm: setOrderForm,
        });
        // use a different variable to store the loading state because if some
        // component uses the `loading` from the Apollo query they won't be perfectly
        // synchronized with our `orderForm` state and could cause some anomalies.
        const [orderFormLoading, setOrderFormLoading] = React.useState(!shouldUseLocalOrderForm);
        const queueStatusRef = useQueueStatus();
        React.useEffect(() => {
            if (loading || error || !data) {
                return;
            }
            const localOrderForm = getLocalOrderForm();
            if (localOrderForm != null) {
                if (!shouldUpdateOrderForm(localOrderForm, data.orderForm) ||
                    // if the queue is fulfilled, we will use the remote order form
                    // regardless of the local status.
                    //
                    // if the queue is pending the remote order form isn't important because
                    // it is expected that when the last task in the queue is finalized, the
                    // component will call `setOrderForm` with the most up-to-date value.
                    queueStatusRef.current !== 'Fulfilled') {
                    setOrderFormLoading(false);
                    setOrderForm((prevOrderForm) => {
                        if (prevOrderForm.id !== defaultOrderForm.id) {
                            return prevOrderForm;
                        }
                        return localOrderForm;
                    });
                    return;
                }
            }
            setOrderForm(data.orderForm);
            setOrderFormLoading(false);
        }, [data, error, loading, queueStatusRef]);
        React.useEffect(() => {
            saveLocalOrderForm(orderForm, log);
        }, [log, orderForm]);
        useOrderFormMessages(orderForm, setOrderForm);
        const value = React.useMemo(() => {
            if (orderForm.id !== DEFAULT_ORDER_FORM_ID) {
                return {
                    error,
                    orderForm: {
                        ...orderForm,
                        value: orderForm.value === UNSYNC_ORDER_FORM_VALUE ? 0 : orderForm.value,
                        messages: {
                            ...orderForm.messages,
                            generalMessages: [],
                        },
                    },
                    initialFetchComplete: true,
                    setOrderForm,
                    loading: orderFormLoading,
                };
            }
            return {
                error,
                orderForm: {
                    ...orderForm,
                    value: orderForm.value === UNSYNC_ORDER_FORM_VALUE ? 0 : orderForm.value,
                    messages: {
                        ...orderForm.messages,
                        generalMessages: [],
                    },
                },
                initialFetchComplete: false,
                setOrderForm,
                loading: orderFormLoading,
            };
        }, [error, orderForm, orderFormLoading]);
        return (React__default['default'].createElement(OrderFormContext.Provider, { value: value }, children));
    };
    return { OrderFormProvider };
}

function createOrderFormProvider({ useToast, useClearOrderFormMessages, useGetOrderForm, useLogger, defaultOrderForm, }) {
    const useOrderFormMessages = createUseMessages({
        useToast,
        useClearOrderFormMessages,
    });
    return createOrderFormProvider$1({
        useOrderFormMessages,
        useGetOrderForm,
        useLogger,
        defaultOrderForm,
    });
}

exports.DEFAULT_ORDER_FORM = DEFAULT_ORDER_FORM;
exports.OrderQueueProvider = OrderQueueProvider;
exports.TASK_CANCELLED_CODE = TASK_CANCELLED_CODE;
exports.createOrderFormProvider = createOrderFormProvider;
exports.useOrderForm = useOrderForm;
exports.useOrderQueue = useOrderQueue;
exports.useQueueStatus = useQueueStatus;
//# sourceMappingURL=index.js.map
